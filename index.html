<!DOCTYPE html>
<html>

<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.17.1/matter.min.js"></script>

    <script src="./client/images_and_data/mSixTankBodyData.js"></script>
    <script src="./client/images_and_data/mSixTankTurretData.js"></script>

    <script>
        function onPageLoad() {
            /*** GLOBAL VARIABLES, APIs, CLASS, AND FUNCTION DEFINITIONS ***/
            window.globals = {};
            window.globals.canvas = document.getElementById("canvas");
            window.globals.context = window.globals.canvas.getContext("2d");
            window.globals.keysDown = {};
            window.globals.images = {};
            window.globals.entities = [];
            window.globals.imagePaths = [
                "./client/images_and_data/ground.png",
                "./client/images_and_data/mSixTankBody.png",
                "./client/images_and_data/mSixTankTurret.png",
            ];

            // Physics APIs (aliases)
            var Engine = Matter.Engine;         // For updating physics.
            var Render = Matter.Render;         // For rendering results of Engine.
            var Bodies = Matter.Bodies;         // To use a pre-made Body.
            var Composite = Matter.Composite;   // Container for entity made of multiple parts.
            var Body = Matter.Body;             // To make a custom Body.
            var Runner = Matter.Runner;         // Optional game loop (Auto updates Engine).
            var Composite = Matter.World;

            class Entity {
                constructor(body, isChild = false) {
                    this.isChild = isChild;
                    if (this.isChild) {
                        this.position = { x: 0, y: 0 };
                        this.rotation = 0;
                    }
                    this.body = body;
                    this.children = [];
                }

                render(ctx) {
                    if (this.isChild) {
                        // If child, move context to local position
                        ctx.save();
                        ctx.translate(this.position.x, this.position.y);
                        ctx.rotate(this.body.angle);
                    } else {
                        // If parent, move context to global position
                        ctx.save();
                        ctx.translate(this.body.position.x, this.body.position.y);
                        ctx.rotate(this.body.angle);
                    }

                    // Render image
                    this.renderThis(ctx);

                    // Render children's images
                    for (let i = 0; i < this.children.length; i++) {
                        const child = this.children[i];
                        child.render(ctx);
                    }

                    // Restore context
                    ctx.restore();
                }

                renderThis(ctx) {
                    // Derived class defines this method
                }

                update(keysDown, dt) {
                    // Apply physics
                    this.updateThis(keysDown, dt);

                    // Apply children's physics
                    for (let i = 0; i < this.children.length; i++) {
                        const child = this.children[i];
                        child.update(keysDown, dt);
                    }
                }

                updateThis(keysdown, dt) {
                    // Derived class defines this method
                }
            }

            class Turret extends Entity {
                constructor(ss, ssData, fps, parent) {
                    super(
                        Bodies.rectangle(parent.body.position.x, parent.body.position.y, 200, 50, {
                            isStatic: false,
                            frictionAir: 0.1,
                            restitution: 0,
                            //density: 0.005,
                            //friction: 0,
                            //inverseInertia: 1,
                            //inertia: Infinity,
                            //frictionStatic: 2,
                            isSensor: true // Turn off body for now!
                        }),
                        true
                    );
                    this.parent = parent;
                    this.speed = 20;

                    // Variables used for rendering this object
                    this.index = 0;
                    this.framesPerSecond = fps;
                    this.timeTracker = 0;
                    this.spriteSheetData = ssData;
                    this.spriteSheet = ss;
                }

                renderThis(ctx) {
                    let ctxCenter = {
                        "x": this.spriteSheetData.frames[this.index].frame.w / 2,
                        "y": this.spriteSheetData.frames[this.index].frame.h / 2
                    };
                    ctx.drawImage(
                        this.spriteSheet,
                        this.spriteSheetData.frames[this.index].frame.x,
                        this.spriteSheetData.frames[this.index].frame.y,
                        this.spriteSheetData.frames[this.index].frame.w,
                        this.spriteSheetData.frames[this.index].frame.h,
                        -ctxCenter.x,
                        -ctxCenter.y,
                        this.spriteSheetData.frames[this.index].frame.w,
                        this.spriteSheetData.frames[this.index].frame.h
                    );
                }

                updateThis(keysDown, dt) {
                    // Set body position to paren
                    Body.setPosition(this.body, this.parent.body.position);

                    // Rotate
                    if (keysDown && keysDown.KeyD == true) {
                        this.body.torque = 0.1;
                    }
                    if (keysDown && keysDown.KeyA == true) {
                        this.body.torque = -0.1;
                    }

                    // Update index
                    this.timeTracker += dt;
                    let delay = 1 / this.framesPerSecond;
                    if (this.timeTracker >= delay) {
                        this.index += 1;
                        this.index = this.index % this.spriteSheetData.frames.length;
                        this.timeTracker = 0;
                    }
                }
            }

            class Tank extends Entity {
                constructor(ss, ssData, fps) {
                    super(
                        Bodies.rectangle(300, 300, 240, 100, {
                            isStatic: false,
                            frictionAir: 0.9,
                            restitution: 0.1,
                            //density: 0.002,
                            //friction: 1,
                            //inverseInertia: 1,
                            //inertia: Infinity,
                            //frictionStatic: 2,
                        }),
                        false
                    );
                    this.children.push(
                        new Turret(
                            window.globals.images["./client/images_and_data/mSixTankTurret.png"],
                            mSixTankTurretData,
                            0,
                            this
                        )
                    );
                    this.speed = 6;
                    this.rotationSpeed = 380;

                    // Variables used for rendering this object
                    this.index = 0;
                    this.framesPerSecond = fps;
                    this.timeTracker = 0;
                    this.spriteSheetData = ssData;
                    this.spriteSheet = ss;
                }

                renderThis(ctx) {
                    let ctxCenter = {
                        "x": this.spriteSheetData.frames[this.index].frame.w / 2,
                        "y": this.spriteSheetData.frames[this.index].frame.h / 2
                    };
                    ctx.drawImage(
                        this.spriteSheet,
                        this.spriteSheetData.frames[this.index].frame.x,
                        this.spriteSheetData.frames[this.index].frame.y,
                        this.spriteSheetData.frames[this.index].frame.w,
                        this.spriteSheetData.frames[this.index].frame.h,
                        -ctxCenter.x,
                        -ctxCenter.y,
                        this.spriteSheetData.frames[this.index].frame.w,
                        this.spriteSheetData.frames[this.index].frame.h
                    );
                }

                updateThis(keysDown, dt) {
                    let dx = Math.cos(this.body.angle) * (this.speed * dt);
                    let dy = Math.sin(this.body.angle) * (this.speed * dt);

                    // Forward/backward
                    if (keysDown && keysDown.ArrowUp == true) {
                        Body.applyForce(
                            this.body,
                            { x: this.body.position.x, y: this.body.position.y },
                            { x: dx, y: dy }
                        );
                    }
                    if (keysDown && keysDown.ArrowDown == true) {
                        Body.applyForce(
                            this.body,
                            { x: this.body.position.x, y: this.body.position.y },
                            { x: -dx, y: -dy }
                        );
                    }

                    // Right/left
                    if (keysDown && keysDown.ArrowRight == true) {
                        this.body.torque = this.rotationSpeed * dt;
                    }
                    if (keysDown && keysDown.ArrowLeft == true) {
                        this.body.torque = -this.rotationSpeed * dt;
                    }

                    // Update index
                    this.timeTracker += dt;
                    let delay = 1 / this.framesPerSecond;
                    if (this.timeTracker >= delay) {
                        this.index += 1;
                        this.index = this.index % this.spriteSheetData.frames.length;
                        this.timeTracker = 0;
                    }
                }
            }

            const setupKeyboardHandler = function (dic) {
                addEventListener("keydown", function (e) {
                    dic[e.code] = true;
                    switch (e.code) {
                        case "ArrowUp":
                        case "ArrowDown":
                        case "ArrowLeft":
                        case "ArrowRight":
                        case "Space":
                            e.preventDefault();
                            break;
                        default:
                            break;
                    }
                }, false);

                addEventListener("keyup", function (e) {
                    delete dic[e.code];
                }, false);
            }

                // Launching Point
                ; (function () {
                    let numImagesLoaded = 0;
                    let numImagesRequested = window.globals.imagePaths.length;
                    for (let i = 0; i < numImagesRequested; i++) {
                        let image = new Image();
                        image.src = window.globals.imagePaths[i];

                        image.onload = function () {
                            window.globals.images[window.globals.imagePaths[i]] = image;
                            numImagesLoaded++;
                            if (numImagesLoaded == numImagesRequested) {
                                Start();
                            }
                        }
                    }
                })();

            const Start = function () {
                setupKeyboardHandler(window.globals.keysDown);
                // Set canvas size
                window.globals.canvas.width = window.innerWidth;
                window.globals.canvas.height = window.innerHeight;

                // Create a physics engine
                var engine = Engine.create({
                    gravity: { x: 0, y: 0 },
                    //enableSleeping: true,
                    //gravity: {x: 3, y:4},
                    //timing: {timeScale: 0.1},
                });

                // *** Use For Debugging *** //
                var render = Render.create({
                    canvas: window.globals.canvas,
                    engine: engine,
                    options: {
                        wireframes: true
                    }
                });
                Render.run(render);

                // Create tank
                var mSixTank = new Tank(
                    window.globals.images["./client/images_and_data/mSixTankBody.png"],
                    mSixTankBodyData,
                    0
                );
                window.globals.entities.push(mSixTank);
                Composite.add(engine.world, [mSixTank.body, mSixTank.children[0].body]);
                // TODO: turn turret body into signal, place it on tank position, see what happens
                // Create box
                var box = Bodies.rectangle(400, 400, 50, 50, { isStatic: true });
                Composite.add(engine.world, [box]);

                /*** Game Loop ***/
                var delta = 0;
                var timeNow = 0;
                var timeThen = 0;
                (function gameLoop(timeStamp) {
                    // Calculate Time between two frames
                    timeNow = (timeStamp == undefined) ? 0 : timeStamp;
                    delta = (timeNow - timeThen) / 1000;

                    // Update entities
                    for (let i = 0; i < window.globals.entities.length; i++) {
                        window.globals.entities[i].update(window.globals.keysDown, delta);
                    }

                    // Update physics
                    Engine.update(engine, 1000 / 60);

                    // Clear canvas
                    //window.globals.context.clearRect(
                    // 0,
                    // 0,
                    // window.globals.canvas.width,
                    // window.globals.canvas.height
                    //);

                    // Draw entities
                    for (let i = 0; i < window.globals.entities.length; i++) {
                        window.globals.entities[i].render(window.globals.context);
                    }

                    // Request to run Game Loop again
                    window.requestAnimationFrame(gameLoop);
                    timeThen = timeNow;
                })();
            }
        }
    </script>
</head>

<body onload="onPageLoad()">
    <div id="canvas-div">
        <canvas id="canvas" width="1000" height="1000" style="position: absolute; z-index: 0;"></canvas>
    </div>
</body>

</html>